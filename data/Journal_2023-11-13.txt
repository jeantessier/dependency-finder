Renamed =InvokeDynamicFinder= to =ListDynamicInstructions=.  Wrote
documentation for this new tool.

I found some documentation on callsites in the javadocs for the
=[[https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/runtime/SwitchBootstraps.html][java.lang.runtime.SwitchBootstraps]]=
class and the
=[[https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/package-summary.html][java.lang.invoke]]=
package.  It is very technical, and I'm not sure how exhaustive it really is.

I'm tempted to move up to Java 21 so I can use type pattern matching in
=switch= expressions.  They make the code much more compact and streamlined.

It turns this somewhat awkward code:

    Object owner = attribute.getOwner();
    if (owner instanceof Classfile) {
        syntheticClasses.add((Classfile) owner);
    } else if (owner instanceof Field_info) {
        syntheticFields.add((Field_info) owner);
    } else if (owner instanceof Method_info) {
        syntheticMethods.add((Method_info) owner);
    } else {
        Logger.getLogger(getClass()).warn("Synthetic attribute on unknown Visitable: " + owner.getClass().getName());
    }

Into this:

    switch (attribute.getOwner()) {
        case Classfile classfile -&gt; syntheticClasses.add(classfile);
        case Field_info fieldInfo -&gt; syntheticFields.add(fieldInfo);
        case Method_info methodInfo -&gt; syntheticMethods.add(methodInfo);
        default -&gt; Logger.getLogger(getClass()).warn("Synthetic attribute on unknown Visitable: " + attribute.getOwner().getClass().getName());
    }

But if I do this, I will need to compile the library to Java 21 and users will
need to be on Java 21 to use Dependency Finder.
