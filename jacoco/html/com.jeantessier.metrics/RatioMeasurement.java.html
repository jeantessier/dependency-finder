<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RatioMeasurement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">com.jeantessier.metrics</a> &gt; <span class="el_source">RatioMeasurement.java</span></div><h1>RatioMeasurement.java</h1><pre class="source lang-java linenums">/*
 *  Copyright (c) 2001-2025, Jean Tessier
 *  All rights reserved.
 *  
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *  
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *  
 *      * Neither the name of Jean Tessier nor the names of his contributors
 *        may be used to endorse or promote products derived from this software
 *        without specific prior written permission.
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.jeantessier.metrics;

import java.io.*;

import org.apache.logging.log4j.*;

/**
 *  &lt;p&gt;Divides one numerical value (base) by another (divider).  Either can be
 *  a numerical constant or the name of another measurement be in the same
 *  context.&lt;/p&gt;
 *
 *  &lt;p&gt;If the result of the division is NaN, you can provide a replacement
 *  value.  The measurement will attempt to coerce the value to a double and
 *  will fall back to NaN if that fails.&lt;/p&gt;
 *
 *  &lt;p&gt;If the result of the division is positive infinity, you can provide a
 *  separate replacement value.  The measurement will attempt to coerce the
 *  value to a double and will fall back to positive infinity if that fails.&lt;/p&gt;
 *
 *  &lt;p&gt;If the result of the division is negative infinity, you can provide a
 *  separate replacement value.  The measurement will attempt to coerce the
 *  value to a double and will fall back to negative infinity if that fails.&lt;/p&gt;
 *
 *  &lt;p&gt;This is the syntax for initializing this type of
 *  measurement:&lt;/p&gt;
 *  
 *  &lt;pre&gt;
 *  &amp;lt;init&amp;gt;
 *      base number | measurement name [DISPOSE_x]
 *      divider number | measurement name [DISPOSE_x]
 *      [number default for NaN]
 *      [number default for positive infinity]
 *      [number default for negative infinity]
 *  &amp;lt;/init&amp;gt;
 *  &lt;/pre&gt;
 *  
 *  &lt;p&gt;If either is missing, this measurement will be NaN.&lt;/p&gt;
 */
public class RatioMeasurement extends ArithmeticMeasurement {
    private String baseTerm;
<span class="fc" id="L73">    private double baseValue = Double.NaN;</span>

    private String dividerTerm;
<span class="fc" id="L76">    private double dividerValue = Double.NaN;</span>

<span class="fc" id="L78">    private double defaultForNaN = Double.NaN;</span>
<span class="fc" id="L79">    private double defaultForPositiveInfinity = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L80">    private double defaultForNegativeInfinity = Double.NEGATIVE_INFINITY;</span>

<span class="fc" id="L82">    private double value = 0.0;</span>
    
    public RatioMeasurement(MeasurementDescriptor descriptor, Metrics context, String initText) {
<span class="fc" id="L85">        super(descriptor, context, initText);</span>

<span class="fc" id="L87">        try (var in = new BufferedReader(new StringReader(initText))) {</span>
<span class="fc" id="L88">            baseTerm = in.readLine().trim();</span>
<span class="fc" id="L89">            dividerTerm = in.readLine().trim();</span>

            try {
<span class="fc" id="L92">                defaultForNaN = Double.parseDouble(in.readLine());</span>
<span class="fc" id="L93">            } catch (NullPointerException | NumberFormatException ex) {</span>
<span class="fc" id="L94">                defaultForNaN = Double.NaN;</span>
<span class="fc" id="L95">            }</span>

            try {
<span class="fc" id="L98">                defaultForPositiveInfinity = Double.parseDouble(in.readLine());</span>
<span class="fc" id="L99">            } catch (NullPointerException | NumberFormatException ex) {</span>
<span class="fc" id="L100">                defaultForPositiveInfinity = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L101">            }</span>

            try {
<span class="fc" id="L104">                defaultForNegativeInfinity = Double.parseDouble(in.readLine());</span>
<span class="fc" id="L105">            } catch (NullPointerException | NumberFormatException ex) {</span>
<span class="fc" id="L106">                defaultForNegativeInfinity = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L107">            }</span>
<span class="fc" id="L108">        } catch (Exception ex) {</span>
<span class="fc" id="L109">            LogManager.getLogger(getClass()).debug(&quot;Cannot initialize with \&quot;{}\&quot;&quot;, initText, ex);</span>
<span class="fc" id="L110">            baseTerm = null;</span>
<span class="fc" id="L111">            dividerTerm = null;</span>
<span class="fc" id="L112">        }</span>
<span class="fc" id="L113">    }</span>
    
    public String getBaseTerm() {
<span class="fc" id="L116">        return baseTerm;</span>
    }

    public double getBaseValue() {
<span class="nc" id="L120">        return baseValue;</span>
    }

    public String getDividerTerm() {
<span class="fc" id="L124">        return dividerTerm;</span>
    }

    public double getDividerValue() {
<span class="nc" id="L128">        return dividerValue;</span>
    }

    public void accept(MeasurementVisitor visitor) {
<span class="fc" id="L132">        visitor.visitRatioMeasurement(this);</span>
<span class="fc" id="L133">    }</span>

    public boolean isEmpty() {
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (!isCached()) {</span>
<span class="fc" id="L137">            compute();</span>
        }

<span class="fc" id="L140">        return super.isEmpty();</span>
    }

    protected double compute() {
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (!isCached()) {</span>
<span class="fc" id="L145">            value = Double.NaN;</span>

<span class="pc bpc" id="L147" title="1 of 4 branches missed.">            if (getBaseTerm() != null &amp;&amp; getDividerTerm() != null) {</span>
<span class="fc" id="L148">                baseValue = evaluateTerm(getBaseTerm());</span>
<span class="fc" id="L149">                dividerValue = evaluateTerm(getDividerTerm());</span>

<span class="fc" id="L151">                value = baseValue / dividerValue;</span>

<span class="fc bfc" id="L153" title="All 2 branches covered.">                if (Double.isNaN(value)) {</span>
<span class="fc" id="L154">                    value = defaultForNaN;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                } else if (Double.isInfinite(value)) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                    value = value &gt; 0 ? defaultForPositiveInfinity : defaultForNegativeInfinity;</span>
                }
            }

<span class="fc bfc" id="L160" title="All 4 branches covered.">            setEmpty(Double.isNaN(value) || Double.isInfinite(value));</span>

<span class="fc" id="L162">            setCached(true);</span>
        }
        
<span class="fc" id="L165">        return value;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>