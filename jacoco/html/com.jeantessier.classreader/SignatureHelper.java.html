<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SignatureHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">com.jeantessier.classreader</a> &gt; <span class="el_source">SignatureHelper.java</span></div><h1>SignatureHelper.java</h1><pre class="source lang-java linenums">/*
 *  Copyright (c) 2001-2024, Jean Tessier
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *
 *      * Neither the name of Jean Tessier nor the names of his contributors
 *        may be used to endorse or promote products derived from this software
 *        without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.jeantessier.classreader;

import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import org.apache.logging.log4j.*;

public final class SignatureHelper {
<span class="fc" id="L43">    private static final Map&lt;String, String&gt; conversion = Map.of(</span>
            &quot;B&quot;, &quot;byte&quot;,
            &quot;C&quot;, &quot;char&quot;,
            &quot;D&quot;, &quot;double&quot;,
            &quot;F&quot;, &quot;float&quot;,
            &quot;I&quot;, &quot;int&quot;,
            &quot;J&quot;, &quot;long&quot;,
            &quot;S&quot;, &quot;short&quot;,
            &quot;V&quot;, &quot;void&quot;,
            &quot;Z&quot;, &quot;boolean&quot;
    );

    private SignatureHelper() {
        // Prevent instantiation
    }

    public static String convert(String type) {
<span class="fc" id="L60">        String result = null;</span>

<span class="fc" id="L62">        LogManager.getLogger(SignatureHelper.class).debug(&quot;Begin Convert(\&quot;{}\&quot;)&quot;, type);</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (type.length() == 1) {</span>
<span class="fc" id="L65">            result = conversion.get(type);</span>
<span class="fc bfc" id="L66" title="All 4 branches covered.">        } else if (type.charAt(0) == 'L' &amp;&amp; type.indexOf(';') != -1) {</span>
<span class="fc" id="L67">            result = ClassNameHelper.path2ClassName(type.substring(1, type.indexOf(';')));</span>
<span class="fc bfc" id="L68" title="All 4 branches covered.">        } else if (type.charAt(0) == 'T' &amp;&amp; type.indexOf(';') != -1) {</span>
<span class="fc" id="L69">            result = ClassNameHelper.path2ClassName(type.substring(1, type.indexOf(';')));</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        } else if (type.charAt(0) == '[') {</span>
<span class="fc" id="L71">            result = convert(type.substring(1)) + &quot;[]&quot;;</span>
        }

<span class="fc" id="L74">        LogManager.getLogger(SignatureHelper.class).debug(&quot;End   Convert(\&quot;{}\&quot;): \&quot;{}\&quot;&quot;, type, result);</span>

<span class="fc" id="L76">        return result;</span>
    }

    public static String getSignature(String descriptor) {
<span class="fc" id="L80">        StringBuilder result = new StringBuilder();</span>

<span class="fc" id="L82">        LogManager.getLogger(SignatureHelper.class).debug(&quot;Begin Signature(\&quot;{}\&quot;)&quot;, descriptor);</span>

<span class="fc" id="L84">        result.append(&quot;(&quot;);</span>

<span class="fc" id="L86">        int start = descriptor.indexOf(&quot;(&quot;) + 1;</span>
<span class="fc" id="L87">        int end   = descriptor.indexOf(&quot;)&quot;);</span>

<span class="fc" id="L89">        result.append(</span>
<span class="fc" id="L90">                StreamSupport.stream(new SignatureSpliterator(descriptor.substring(start, end)), false)</span>
<span class="fc" id="L91">                        .collect(Collectors.joining(&quot;, &quot;))</span>
        );

<span class="fc" id="L94">        result.append(&quot;)&quot;);</span>

<span class="fc" id="L96">        LogManager.getLogger(SignatureHelper.class).debug(&quot;End   Signature(\&quot;{}\&quot;): \&quot;{}\&quot;&quot;, descriptor, result);</span>

<span class="fc" id="L98">        return result.toString();</span>
    }

    public static int getParameterCount(String descriptor) {
<span class="fc" id="L102">        LogManager.getLogger(SignatureHelper.class).debug(&quot;Begin ParameterCount(\&quot;{}\&quot;)&quot;, descriptor);</span>

<span class="fc" id="L104">        int start = descriptor.indexOf(&quot;(&quot;) + 1;</span>
<span class="fc" id="L105">        int end   = descriptor.indexOf(&quot;)&quot;);</span>

<span class="fc" id="L107">        var result = (int) StreamSupport.stream(new SignatureSpliterator(descriptor.substring(start, end)), false).count();</span>

<span class="fc" id="L109">        LogManager.getLogger(SignatureHelper.class).debug(&quot;End   ParameterCount(\&quot;{}\&quot;): \&quot;{}\&quot;&quot;, descriptor, result);</span>

<span class="fc" id="L111">        return result;</span>
    }

    public static String getReturnType(String descriptor) {
<span class="fc" id="L115">        return convert(descriptor.substring(descriptor.lastIndexOf(&quot;)&quot;) + 1));</span>
    }

    public static String getType(String descriptor) {
<span class="nc" id="L119">        return convert(descriptor);</span>
    }

    private static class SignatureSpliterator implements Spliterator&lt;String&gt; {
        private final String descriptor;

<span class="fc" id="L125">        private int currentPos = 0;</span>

<span class="fc" id="L127">        public SignatureSpliterator(String descriptor) {</span>
<span class="fc" id="L128">            this.descriptor = descriptor;</span>
<span class="fc" id="L129">        }</span>

        public boolean tryAdvance(Consumer&lt;? super String&gt; action) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">            if (!hasMore()) {</span>
<span class="fc" id="L133">                return false;</span>
            }

<span class="fc" id="L136">            int nextPos = currentPos;</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">            while (descriptor.charAt(nextPos) == '[') {</span>
<span class="fc" id="L139">                nextPos++;</span>
            }

<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (descriptor.charAt(nextPos) == 'L') {</span>
<span class="fc" id="L143">                nextPos = descriptor.indexOf(&quot;;&quot;, nextPos);</span>
            }

<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (descriptor.charAt(nextPos) == 'T') {</span>
<span class="fc" id="L147">                nextPos = descriptor.indexOf(&quot;;&quot;, nextPos);</span>
            }

<span class="fc" id="L150">            action.accept(SignatureHelper.convert(descriptor.substring(currentPos, nextPos + 1)));</span>

<span class="fc" id="L152">            currentPos = nextPos + 1;</span>

<span class="fc" id="L154">            return true;</span>
        }

        private boolean hasMore() {
<span class="fc bfc" id="L158" title="All 2 branches covered.">            return currentPos &lt; descriptor.length();</span>
        }

        public Spliterator&lt;String&gt; trySplit() {
<span class="nc" id="L162">            return null;</span>
        }

        public long estimateSize() {
<span class="nc" id="L166">            return descriptor.length() - currentPos;</span>
        }

        public int characteristics() {
<span class="fc" id="L170">            return NONNULL + IMMUTABLE;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>