<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CodeDependencyCollector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">com.jeantessier.dependency</a> &gt; <span class="el_source">CodeDependencyCollector.java</span></div><h1>CodeDependencyCollector.java</h1><pre class="source lang-java linenums">/*
 *  Copyright (c) 2001-2024, Jean Tessier
 *  All rights reserved.
 *  
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *  
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *  
 *      * Neither the name of Jean Tessier nor the names of his contributors
 *        may be used to endorse or promote products derived from this software
 *        without specific prior written permission.
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.jeantessier.dependency;

import java.util.*;

import org.apache.logging.log4j.*;

import com.jeantessier.classreader.*;

/**
 * &lt;p&gt;Traverses a Classfile and extracts dependencies from its code.&lt;/p&gt;
 *
 * &lt;p&gt;Known limitations:&lt;/p&gt;
 * &lt;ul&gt;
 *     &lt;li&gt;Does not see dependencies on &lt;code&gt;static final&lt;/code&gt; constants of
 *         primitive types or String&lt;/li&gt;
 *     &lt;li&gt;Does not look at local variables&lt;/li&gt;
 * &lt;/ul&gt;
 */
public class CodeDependencyCollector extends com.jeantessier.classreader.VisitorBase {
    private final NodeFactory factory;
    private final SelectionCriteria filterCriteria;

    private Node current;

<span class="fc" id="L57">    private final Collection&lt;DependencyListener&gt; dependencyListeners = new HashSet&lt;&gt;();</span>

    public CodeDependencyCollector() {
<span class="fc" id="L60">        this(new NodeFactory());</span>
<span class="fc" id="L61">    }</span>

    public CodeDependencyCollector(NodeFactory factory) {
<span class="fc" id="L64">        this(factory, new ComprehensiveSelectionCriteria());</span>
<span class="fc" id="L65">    }</span>

<span class="fc" id="L67">    public CodeDependencyCollector(NodeFactory factory, SelectionCriteria filterCriteria) {</span>
<span class="fc" id="L68">        this.factory = factory;</span>
<span class="fc" id="L69">        this.filterCriteria = filterCriteria;</span>
<span class="fc" id="L70">    }</span>

    public NodeFactory getFactory() {
<span class="fc" id="L73">        return factory;</span>
    }

    private Node getCurrent() {
<span class="fc" id="L77">        return current;</span>
    }

    /**
     * Visible for testing only
     */
    void setCurrent(Node current) {
<span class="fc" id="L84">        this.current = current;</span>
<span class="fc" id="L85">    }</span>

    public void visitClassfile(Classfile classfile) {
<span class="fc" id="L88">        ClassNode currentClass = getFactory().createClass(classfile.getClassName(), true);</span>
<span class="fc" id="L89">        setCurrent(currentClass);</span>

<span class="fc" id="L91">        fireBeginClass(classfile.getClassName());</span>

<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (classfile.hasSuperclass()) {</span>
<span class="fc" id="L94">            Class_info superclass = classfile.getRawSuperclass();</span>
<span class="fc" id="L95">            superclass.accept(this);</span>
<span class="fc" id="L96">            currentClass.addParent(getFactory().createClass(superclass.getName()));</span>
        }

<span class="fc bfc" id="L99" title="All 2 branches covered.">        for (Class_info class_info : classfile.getAllInterfaces()) {</span>
<span class="fc" id="L100">            class_info.accept(this);</span>
<span class="fc" id="L101">            currentClass.addParent(getFactory().createClass(class_info.getName()));</span>
<span class="fc" id="L102">        }</span>

<span class="fc" id="L104">        super.visitClassfile(classfile);</span>

<span class="fc" id="L106">        fireEndClass(classfile.getClassName());</span>
<span class="fc" id="L107">    }</span>

    protected void visitClassfileAttributes(Classfile classfile) {
<span class="fc" id="L110">        setCurrent(getFactory().createClass(classfile.getClassName()));</span>
<span class="fc" id="L111">        super.visitClassfileAttributes(classfile);</span>
<span class="fc" id="L112">    }</span>

    public void visitClass_info(Class_info entry) {
<span class="fc" id="L115">        String classname = entry.getName();</span>
<span class="fc" id="L116">        LogManager.getLogger(getClass()).debug(&quot;VisitClass_info():&quot;);</span>
<span class="fc" id="L117">        LogManager.getLogger(getClass()).debug(&quot;    name = \&quot;{}\&quot;&quot;, classname);</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (entry.getRawName().getValue().startsWith(&quot;[&quot;)) {</span>
<span class="fc" id="L120">            processDescriptor(entry.getRawName().getValue());</span>
        } else {
<span class="fc" id="L122">            processClassName(classname);</span>
        }

<span class="fc" id="L125">        super.visitClass_info(entry);</span>
<span class="fc" id="L126">    }</span>

    public void visitFieldRef_info(FieldRef_info entry) {
<span class="fc" id="L129">        LogManager.getLogger(getClass()).debug(&quot;VisitFieldRef_info():&quot;);</span>
<span class="pc" id="L130">        LogManager.getLogger(getClass()).debug(&quot;    class = \&quot;{}\&quot;&quot;, () -&gt; entry.getClassName());</span>
<span class="pc" id="L131">        LogManager.getLogger(getClass()).debug(&quot;    name = \&quot;{}\&quot;&quot;, () -&gt; entry.getRawNameAndType().getName());</span>
<span class="pc" id="L132">        LogManager.getLogger(getClass()).debug(&quot;    type = \&quot;{}\&quot;&quot;, () -&gt; entry.getRawNameAndType().getType());</span>

<span class="fc" id="L134">        String name = entry.getFullUniqueName();</span>
<span class="pc bpc" id="L135" title="2 of 4 branches missed.">        if (filterCriteria.isMatchingFeatures() &amp;&amp; filterCriteria.matchesFeatureName(name)) {</span>
<span class="fc" id="L136">            Node other = getFactory().createFeature(name);</span>
<span class="fc" id="L137">            getCurrent().addDependency(other);</span>
<span class="fc" id="L138">            LogManager.getLogger(getClass()).info(&quot;FieldRef_info dependency: {} --&gt; {}&quot;, getCurrent(), other);</span>
<span class="fc" id="L139">            fireDependency(getCurrent(), other);</span>
        }

<span class="fc" id="L142">        processDescriptor(entry.getRawNameAndType().getType());</span>

<span class="fc" id="L144">        super.visitFieldRef_info(entry);</span>
<span class="fc" id="L145">    }</span>

    public void visitMethodRef_info(MethodRef_info entry) {
<span class="fc" id="L148">        LogManager.getLogger(getClass()).debug(&quot;VisitMethodRef_info():&quot;);</span>
<span class="pc" id="L149">        LogManager.getLogger(getClass()).debug(&quot;    class = \&quot;{}\&quot;&quot;, () -&gt; entry.getClassName());</span>
<span class="pc" id="L150">        LogManager.getLogger(getClass()).debug(&quot;    name = \&quot;{}\&quot;&quot;, () -&gt; entry.getRawNameAndType().getName());</span>
<span class="pc" id="L151">        LogManager.getLogger(getClass()).debug(&quot;    type = \&quot;{}\&quot;&quot;, () -&gt; entry.getRawNameAndType().getType());</span>

<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if (!entry.isStaticInitializer()) {</span>
<span class="fc" id="L154">            String name = entry.getFullUniqueName();</span>
<span class="pc bpc" id="L155" title="1 of 4 branches missed.">            if (filterCriteria.isMatchingFeatures() &amp;&amp; filterCriteria.matchesFeatureName(name)) {</span>
<span class="fc" id="L156">                Node other  = getFactory().createFeature(name);</span>
<span class="fc" id="L157">                getCurrent().addDependency(other);</span>
<span class="fc" id="L158">                LogManager.getLogger(getClass()).info(&quot;MethodRef_info dependency: {} --&gt; {}&quot;, getCurrent(), other);</span>
<span class="fc" id="L159">                fireDependency(getCurrent(), other);</span>
            }

<span class="fc" id="L162">            processDescriptor(entry.getRawNameAndType().getType());</span>
        }

<span class="fc" id="L165">        super.visitMethodRef_info(entry);</span>
<span class="fc" id="L166">    }</span>

    public void visitInterfaceMethodRef_info(InterfaceMethodRef_info entry) {
<span class="nc" id="L169">        LogManager.getLogger(getClass()).debug(&quot;VisitInterfaceMethodRef_info():&quot;);</span>
<span class="nc" id="L170">        LogManager.getLogger(getClass()).debug(&quot;    class = \&quot;{}\&quot;&quot;, () -&gt; entry.getClassName());</span>
<span class="nc" id="L171">        LogManager.getLogger(getClass()).debug(&quot;    name = \&quot;{}\&quot;&quot;, () -&gt; entry.getRawNameAndType().getName());</span>
<span class="nc" id="L172">        LogManager.getLogger(getClass()).debug(&quot;    type = \&quot;{}\&quot;&quot;, () -&gt; entry.getRawNameAndType().getType());</span>

<span class="nc" id="L174">        String name = entry.getFullUniqueName();</span>
<span class="nc bnc" id="L175" title="All 4 branches missed.">        if (filterCriteria.isMatchingFeatures() &amp;&amp; filterCriteria.matchesFeatureName(name)) {</span>
<span class="nc" id="L176">            Node other  = getFactory().createFeature(name);</span>
<span class="nc" id="L177">            getCurrent().addDependency(other);</span>
<span class="nc" id="L178">            LogManager.getLogger(getClass()).info(&quot;InterfaceMethodRef_info dependency: {} --&gt; {}&quot;, getCurrent(), other);</span>
<span class="nc" id="L179">            fireDependency(getCurrent(), other);</span>
        }

<span class="nc" id="L182">        processDescriptor(entry.getRawNameAndType().getType());</span>

<span class="nc" id="L184">        super.visitInterfaceMethodRef_info(entry);</span>
<span class="nc" id="L185">    }</span>

    public void visitField_info(Field_info entry) {
<span class="fc" id="L188">        LogManager.getLogger(getClass()).debug(&quot;VisitField_info():&quot;);</span>
<span class="pc" id="L189">        LogManager.getLogger(getClass()).debug(&quot;    name = \&quot;{}\&quot;&quot;, () -&gt; entry.getName());</span>
<span class="pc" id="L190">        LogManager.getLogger(getClass()).debug(&quot;    descriptor = \&quot;{}\&quot;&quot;, () -&gt; entry.getDescriptor());</span>

<span class="fc" id="L192">        setCurrent(getFactory().createFeature(entry.getFullUniqueName(), true));</span>

<span class="fc" id="L194">        processDescriptor(entry.getDescriptor());</span>

<span class="fc" id="L196">        super.visitField_info(entry);</span>
<span class="fc" id="L197">    }</span>

    public void visitMethod_info(Method_info entry) {
<span class="fc" id="L200">        LogManager.getLogger(getClass()).debug(&quot;VisitMethod_info():&quot;);</span>
<span class="pc" id="L201">        LogManager.getLogger(getClass()).debug(&quot;    name = \&quot;{}\&quot;&quot;, () -&gt; entry.getName());</span>
<span class="pc" id="L202">        LogManager.getLogger(getClass()).debug(&quot;    descriptor = \&quot;{}\&quot;&quot;, () -&gt; entry.getDescriptor());</span>

<span class="fc" id="L204">        setCurrent(getFactory().createFeature(entry.getFullUniqueName(), true));</span>

<span class="fc" id="L206">        processDescriptor(entry.getDescriptor());</span>

<span class="fc" id="L208">        super.visitMethod_info(entry);</span>
<span class="fc" id="L209">    }</span>

    public void visitInstruction(Instruction helper) {
<span class="fc" id="L212">        LogManager.getLogger(getClass()).debug(&quot;VisitInstruction() ...&quot;);</span>

        /*
         *  We can skip the &quot;new&quot; (0xbb) instruction as it is always
         *  followed by a call to the constructor method.
         */

<span class="fc bfc" id="L219" title="All 3 branches covered.">        switch (helper.getOpcode()) {</span>
            case 0x12: // ldc
            case 0x13: // ldc_w
            case 0xb2: // getstatic
            case 0xb3: // putstatic
            case 0xb4: // getfield
            case 0xb5: // putfield
            case 0xb6: // invokevirtual
            case 0xb7: // invokespecial
            case 0xb8: // invokestatic
            case 0xb9: // invokeinterface
            // case 0xbb: // new
            case 0xbd: // anewarray
            case 0xc0: // checkcast
            case 0xc1: // instanceof
            case 0xc5: // multianewarray
<span class="fc" id="L235">                helper.getIndexedConstantPoolEntry().accept(this);</span>
<span class="fc" id="L236">                break;</span>
            case 0xba: // invokedynamic
<span class="fc" id="L238">                helper.getDynamicConstantPoolEntries().forEach(entry -&gt; entry.accept(this));</span>
<span class="fc" id="L239">                break;</span>
            default:
                // Do nothing
                break;
        }

<span class="fc" id="L245">        super.visitInstruction(helper);</span>
<span class="fc" id="L246">    }</span>

    public void visitExceptionHandler(ExceptionHandler helper) {
<span class="fc" id="L249">        LogManager.getLogger(getClass()).debug(&quot;{}VisitExceptionHandler(): {}&quot;, getClass().getName(), helper);</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (helper.hasCatchType()) {</span>
<span class="fc" id="L252">            helper.getRawCatchType().accept(this);</span>
        }

<span class="fc" id="L255">        super.visitExceptionHandler(helper);</span>
<span class="fc" id="L256">    }</span>

    public void visitAnnotation(Annotation helper) {
<span class="fc" id="L259">        processClassName(helper.getType());</span>

<span class="fc" id="L261">        super.visitAnnotation(helper);</span>
<span class="fc" id="L262">    }</span>

    public void visitEnumElementValue(EnumElementValue helper) {
<span class="fc" id="L265">        String signature = helper.getTypeName() + &quot;.&quot; + helper.getConstName();</span>
<span class="pc bpc" id="L266" title="2 of 4 branches missed.">        if (filterCriteria.isMatchingFeatures() &amp;&amp; filterCriteria.matchesFeatureName(signature)) {</span>
<span class="fc" id="L267">            Node other = getFactory().createFeature(signature);</span>
<span class="fc" id="L268">            getCurrent().addDependency(other);</span>
<span class="fc" id="L269">            LogManager.getLogger(getClass()).info(&quot;EnumElementValue dependency: {} --&gt; {}&quot;, getCurrent(), other);</span>
<span class="fc" id="L270">            fireDependency(getCurrent(), other);</span>
        }

<span class="fc" id="L273">        super.visitEnumElementValue(helper);</span>
<span class="fc" id="L274">    }</span>

    public void visitClassElementValue(ClassElementValue helper) {
<span class="fc" id="L277">        processClassName(helper.getClassInfo());</span>

<span class="fc" id="L279">        super.visitClassElementValue(helper);</span>
<span class="fc" id="L280">    }</span>

    private void processDescriptor(String str) {
<span class="fc" id="L283">        int currentPos = 0;</span>
        int startPos;
        int endPos;

<span class="fc bfc" id="L287" title="All 2 branches covered.">        while ((startPos = str.indexOf('L', currentPos)) != -1) {</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            if ((endPos = str.indexOf(';', startPos)) != -1) {</span>
<span class="fc" id="L289">                processClassName(ClassNameHelper.path2ClassName(str.substring(startPos + 1, endPos)));</span>
<span class="fc" id="L290">                currentPos = endPos + 1;</span>
            } else {
<span class="nc" id="L292">                currentPos = startPos + 1;</span>
            }
        }
<span class="fc" id="L295">    }</span>

    private void processClassName(String classname) {
<span class="pc bpc" id="L298" title="1 of 4 branches missed.">        if (filterCriteria.isMatchingClasses() &amp;&amp; filterCriteria.matchesClassName(classname)) {</span>
<span class="fc" id="L299">            LogManager.getLogger(getClass()).debug(&quot;    Adding \&quot;{}\&quot;&quot;, classname);</span>
<span class="fc" id="L300">            Node other = getFactory().createClass(classname);</span>
<span class="fc" id="L301">            getCurrent().addDependency(other);</span>
<span class="fc" id="L302">            LogManager.getLogger(getClass()).info(&quot;Class_info dependency: {} --&gt; {}&quot;, getCurrent(), other);</span>
<span class="fc" id="L303">            fireDependency(getCurrent(), other);</span>
        }
<span class="fc" id="L305">    }</span>

    public void addDependencyListener(DependencyListener listener) {
<span class="fc" id="L308">        dependencyListeners.add(listener);</span>
<span class="fc" id="L309">    }</span>

    public void removeDependencyListener(DependencyListener listener) {
<span class="nc" id="L312">        dependencyListeners.remove(listener);</span>
<span class="nc" id="L313">    }</span>

    protected void fireBeginSession() {
<span class="nc" id="L316">        DependencyEvent event = new DependencyEvent(this);</span>
<span class="nc" id="L317">        dependencyListeners.forEach(listener -&gt; listener.beginSession(event));</span>
<span class="nc" id="L318">    }</span>

    protected void fireBeginClass(String classname) {
<span class="fc" id="L321">        DependencyEvent event = new DependencyEvent(this, classname);</span>
<span class="fc" id="L322">        dependencyListeners.forEach(listener -&gt; listener.beginClass(event));</span>
<span class="fc" id="L323">    }</span>

    protected void fireDependency(Node dependent, Node dependable) {
<span class="fc" id="L326">        DependencyEvent event = new DependencyEvent(this, dependent, dependable);</span>
<span class="fc" id="L327">        dependencyListeners.forEach(listener -&gt; listener.dependency(event));</span>
<span class="fc" id="L328">    }</span>

    protected void fireEndClass(String classname) {
<span class="fc" id="L331">        DependencyEvent event = new DependencyEvent(this, classname);</span>
<span class="fc" id="L332">        dependencyListeners.forEach(listener -&gt; listener.endClass(event));</span>
<span class="fc" id="L333">    }</span>

    protected void fireEndSession() {
<span class="nc" id="L336">        DependencyEvent event = new DependencyEvent(this);</span>
<span class="nc" id="L337">        dependencyListeners.forEach(listener -&gt; listener.endSession(event));</span>
<span class="nc" id="L338">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>